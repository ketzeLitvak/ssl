# Fases De Traducción y Errores
## Curso K2051 - Ezequiel Ilan Litvak
 
**Acerca del compilador**
Las funciones y opciones que presenta mi compilador, el gcc, se pueden observar en la terminal al hacer el siguiente comando: "gcc --help".
 
**Secuencia de pasos**
 
*Preprocesador*

1a. [hello2.c](https://github.com/ketzeLitvak/ssl/blob/main/02-FasesErrores/hello2.c)

1b. Para poder preprocesar el hello2.c, se usa el siguiente comando: "gcc -E hello2.c". Sin embargo, de esa forma, el resultado se va a ver todo en la terminal. Para poder verlo mejor, se puede agregar al comando anterior lo siguiente: "-o hello2.i", que va a dirigir la salida del anterior comando a un archivo .i llamado hello2. En el archivo, se puede ver el resultado del preprocesamiento de hello2.c. [hello2.i](https://github.com/ketzeLitvak/ssl/blob/main/02-FasesErrores/hello2.i), en este se puede ver al principio, los headers de las bibliotecas usadas en el #define del hello2.c, los cuales en este caso, son los headers de la parte de la biblioteca estándar llamada stdio, dedicada al manejo de input y output. A su vez, saca del archivo esas declaraciones, es decir, no están los #define en el archivo preprocesado debido a que se intercambiaron por los headers. Al final del mismo, se puede ver también como el preprocesador cambia los comentarios por espacios, como ocurre con el comentario "/*medio*/" del archivo hello2.c. Un detalle importante es que el preprocesador no tuvo problemas en preprocesar el archivo hello2.c por más que este tenía varios problemas sintácticos. Esto se debe a que el preprocesador no tiene la capacidad para ver estos errores. Los números y numerales que están al principio de cada línea son de ayuda para el preprocesador, se pueden sacar si al comando de preprocesamiento se le agrega un "-P".

1c. [hello3.c](https://github.com/ketzeLitvak/ssl/blob/main/02-FasesErrores/hello3.c)

1d. La primera línea es el header de la función llamada "printf" en donde se están declarando sus parámetros. En el primer parámetro se define como "const char* restrict s". Declarar a la variable como const significa que no se puede modificar el valor de lo que está apuntando s, debido a que ese valor es constante. Sin embargo, si se puede modificar el valor al que está apuntando s. s es una variable de tipo char* que significa que es un puntero a una variable de tipo char. Declarar a la variable con la definición restrict es una forma de avisar al compilador que s apunta a un objeto y solo s lo hace, ningún otra variable del programa. Esto ayuda al compilador a saber que si afecta a s, no va a generar un efecto que genere problemas con otras variables del programa, lo cual le ayuda a hacer optimizaciones. Los 3 puntos suspensivos indican que la función "printf" puede tener o no más argumentos que el que esta definido con s.
 
1e. Se preprocesa el archivo hello3.c con el siguiente comando: "gcc -E hello3.c -o hello3.i". [hello3.i](https://github.com/ketzeLitvak/ssl/blob/main/02-FasesErrores/hello3.i), se observa que la única diferencia entre el hello3.c y el hello3.i son los numerales y anotaciones del preprocesador al principio, por lo que si se usa el siguiente comando: "gcc -E hello3.c -P -o hello3SinNumerales.i", se puede ver que al preprocesar el archivo, hello3.c y hello3SinNumerales.i son identicos. El preprocesador no hizo cambios en lo que está escrito, sino que hubo un cambio en el tipo de archivo.
Un detalle para ver es entre el hello3.i y el hello2.i. El primero, como el hello3.c no tenía el #define para la biblioteca estándar, no copio los headers de toda la misma, sin embargo, en el segundo como tenía el #define, se copiaron todos los headers y el archivo quedó más grande.
 
*Compilación*

2a. Se compiló sin ensamblar el archivo hello3.i con el siguiente comando: "gcc hello3.i -S". Al hacerlo, el programa devuelve warnings y errores. Una de las warnings es debido a que "prontf" no está definida, por lo que la toma implícitamente. Debido a los errores no pudo compilar bien, por ejemplo, se esperaba una declaración al final del input (faltaba cerrar la llave del main). Este último es un error sintáctico, el cual ahora sí, el compilador puede ver.

2b. Se compiló sin ensamblar el archivo hello4.c con el siguiente comando: "gcc hello4.c -S". [hello4.s](https://github.com/ketzeLitvak/ssl/blob/main/02-FasesErrores/hello4.s), ahora si compiló correctamente.

2c. El archivo creado, el [hello4.s](https://github.com/ketzeLitvak/ssl/blob/main/02-FasesErrores/hello4.s), es un programa en código de máquina, en assembler, el cual comienza realmente a partir de la linea 10, definiendo _main. Despues hace espacio para la variable i (líneas 18 y 19 en especial), para luego llamar a main (línea 20) en donde se introduce el valor 42 a los espacios liberados para la variable i (línea 21) y se llama a prontf para su ejecución (línea 23), con su valor guardado en la variable LC0 (inicialmente en líneas 5 a 9 y después se lo mueve para la utilización de la función prontf en la línea 22. En la línea 24 se pone un 0 (es el $0 que se introduce, que simboliza el valor literal de 0) en el registro "a" para preparar la finalización del programa. En este caso, el código esta escrito con la notación de intel. 

2d. Para ensamblar, se utiliza el siguiente comando: "gcc hello4.s -c". El resultado es el archivo [hello4.o](https://github.com/ketzeLitvak/ssl/blob/main/02-FasesErrores/hello4.o), el cual se ensamblo correctamente sin problemas, por lo que desde el punto de vista del compilador no hay problemas. Si se hubiera ensamblado el archivo hello4.c con el siguiente comando: "gcc hello4.c -c", se hubiera ensamblado correctamente también, sin embargo, en la terminal se muestra un warning acerca de la declaración implícita de la función prontf. No se puede ver el archivo hello4.o directamente desde la IDE, debido a que son bytes. Sin embargo, hay formas de poder ver directamente los bytes, o representados en ASCII.
 
*Vinculación*

3a. Se vincula el archivo hello4.o con el siguiente comando: "gcc hello4.o -o hello4.exe". El comando tira un error en la consola y no se vincula correctamente. El error es "undefined reference to `prontf'", el cual es un error de vinculación, debido a que el linker no sabe a que vincular la función prontf ya que no tiene definición. A su vez, en el error se muestra la dirección al linker, en mi caso "a:/mingw/bin/../lib/gcc/mingw32/9.2.0/../../../../mingw32/bin/ld.exe". Se puede observar que el ejecutable "ld.exe" seria el linker que utiliza el mingw32, el cual en nuestro caso, retorno 1 ("ld returned 1 exit status") por lo que al no ser 0 se toma como error.

3b. Los cambios estan en [hello5.c](https://github.com/ketzeLitvak/ssl/blob/main/02-FasesErrores/hello5.c). Para que vincule correctamente, se cambió la llamada a "prontf" por "printf", que se definió previamente. El comando para vincular es: "gcc hello5.c -o hello5.exe".

3c. El resultado es [hello5.exe](https://github.com/ketzeLitvak/ssl/blob/main/02-FasesErrores/hello5.exe). El programa ejecuta perfectamente, sin embargo, hay un error pragmatico, ya que printf esta esperando un int en el string (al escribir el %d). Pero como no se lo esta pasando, se queda un valor basura. Esto sucede ya que no estamos cumpliendo con el contrato de printf. Sin embargo, esto ultimo va a depender de la maquina en la que se utilice, en algunas maquinas puede ser que falle directamente. El problema es que al romper el contrato, se puede esperar cualquier cosa de resultado. En mi caso, al usar gcc, el compilador toma implicitamente la definición de printf de la biblioteca estándar, por más que en el código no se haya llamado en un #define a la misma. Por lo tanto, no va a tener problemas para ejecutarlo, ya que esta función sabe que al no recibir los valores que espera, tiene que mostrar un valor basura para no romper el programa (es bastante flexible cuando el programa es compilado en gcc).

*Corrección de Bug* 

4a. El archivo [hello6.c](https://github.com/ketzeLitvak/ssl/blob/main/02-FasesErrores/hello6.c) es la versión arreglada, se utiliza la variable i para que sea mostrada en la función printf. Se vuelve a compilar y vincular con "gcc hello6.c -o hello6.exe". El resultado es el archivo ejecutable [hello6.exe](https://github.com/ketzeLitvak/ssl/blob/main/02-FasesErrores/hello6.exe), el cual no tiene ningun problema y devuelve correctamente: "La respuesta es 42".

*Remoción de prototipo*

5a. Creación del archivo [hello7.c](https://github.com/ketzeLitvak/ssl/blob/main/02-FasesErrores/hello7.c)

5b. El archivo hello7.c compila y ejecuta correctamente (muestra como resultado ""La respuesta es 42"), con el simple hecho que tira unas warnings "implicit declaration of function 'printf'" y "incompatible implicit declaration of built-in function 'printf'". La primera expresa que la función printf no fue declarada previamente, por lo que no esta definido un contrato para la misma. La segunda declara denuevo que es una función declarada implicitamente, sin embargo, da a entender que es "built-in", es decir, que es una función que esta prearmada en el compilador. Por esto ultimo es que funciona correctamente el programa, debido a que la definición de printf ya esta incorporada en el compilador, entonces este ya sabe que hacer cuando encuentra su llamado. El mismo compilador, por más que puede funcionar igualmente, muestra una nota con las warnings diciendo "include '<stdio.h>' or provide a declaration of 'printf'", dando a entender que es una buena práctica incluir la declaración de la función.